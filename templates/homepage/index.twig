{% set dataModel = 
    {
        "intro": "Welcome to Papertrain",
        "introCopy": "If you already have experience with Papertrain v0.4 delete this <code>homepage/</code> directory and get started. If you havn't, you should read through the following documentation. Papertrain uses the <a href=\"https://jintmethod.dev/\" target=\"_blank\">JINT methodology</a> for loading stylesheets, scripts, and images. When rendering content you should consider if rendering on the server-side or the client-side would be better depending on the context and desired functionality. Our job is to provide the user with data in a meaningful way and Papertrain defines meaningful as fast and reliable over visual design and mico-animations.",
        "links": [
            {
                "name": "#templates",
                "label": "Templates"
            },
            {
                "name": "#web-components",
                "label": "Web Components"
            },
            {
                "name": "#web-modules",
                "label": "Web Modules"
            },
            {
                "name": "#npm-packages",
                "label": "Adding NPM Packages"
            },
            {
                "name": "#libraries",
                "label": "Adding 3rd Party Libraries"
            }
        ],
        "templates": {
            "heading": "Templates",
            "body": "<p>Templates consist of two key parts: an <code>&lt;article&gt;</code> element a <a href=\"https://twig.symfony.com/doc/2.x/tags/set.html\" target=\"_blank\">twig variable</a> named <code>dataModel</code>. Twig variables use a similar syntax to JSON so if you have any experience with that you should be able to pick up on writing twig variables relatively quickly. We use a data model twig variable to quickly mock-up the template's content allowing our templates data structure to be agnostic of the CMS. This means that we could hook-up the template structure to any CMS we choose as long as the Twig templating engine is used.</p>
            <p>Creating new templates is easy when using the Papertrain code generator. It will produce a basic version of a template along with its SCSS file in the location you provide. To generate a new template enter the following command into your terminal:</p>
            <codeblock>npm run create</codeblock>
            <p>When prompted to enter the template name enter the name <code>example</code> and select the <code>Template</code> option from the list. Generated files are placed relative to the <code>templates/</code> directory. You can enter a custom path or you can press enter to place the files directly in the templates directory. Once the generator is finished you can view your new page at <a href=\"" ~ siteUrl|trim('/') ~ "/example\" target=\"_blank\">" ~ siteUrl|trim('/') ~ "/example</a> and you can edit the twig and scss files at <code>templates/example/</code>.</p>
            <p>Be default templates scss files are loaded using the <code>eager-load-css</code> attribute attached to the <code>&lt;artilce&gt;</code> element. This attribute will tell the runtime script not to display the page until the file has loaded.</p>",
        },
        "webComponents": {
            "heading": "Web Components",
            "body": "<p>Web components are the bread and butter of Papertrain. You will spend most of your time developing web components or their pre-web component state known as custom elements. Before diving into how web components work we will briefly cover their foundation.</p>
            <p>Custom elements are HTML elements with unique functionality as defined by the <a href=\"https://html.spec.whatwg.org/multipage/custom-elements.html\" target=\"_blank\">HTML spec</a>. Their tag names must be lowercase, kebab-case, and must contain at least one hyphen. Custom elements are upgraded into web components when a script is loaded that registers the custom element with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry\" target=\"_blank\">Custom Element Registry</a>. Once the script is loaded the browser will connect all custom elements within the DOM with an instance of the class provided to the custom element registry. At that point, the custom elements <code>connectedCallback()</code> method is called and the web component has been mounted.</p>
            <p>Let's cover the benefits of using web components. When a web component is mounted the custom elements in the DOM the web components script merge. In the component's script, the <code>this</code> keyword refers to both the script and the node within the DOM. When you call <code>this.remove()</code> the node will be removed from the DOM and the instance of the class will be removed from memory. Since scripts and elements are directly linked it means you could use a query selector get to the element and then you could call public methods from the web component. The second key benefit is that new web components will be mounted when new custom elements are added to the DOM either through <code>document.body.append(element)</code> or <code>document.body.innerHTML += '&lt;custom-element&gt;&lt;/custom-element&gt;'</code>. This means we don't have to manage a relationship between the elements in the DOM and the class instances in memory.</p>
            <p>Creating web components is easy when using the Papertrain code generator. Web components are generated with a basic twig, scss, and JavaScript/TypeScript file. To generate a new web component enter the following command in your terminal:</p>
            <codeblock>npm run create</codeblock>
            <p>Name the web component <code>demo</code> then select <code>Web Component</code> from the list. When choosing a script type it's recommended that you select TypeScript, however, JavaScript is available. When asked where to place the web component place the component in the example template you created by entering <code>example</code>. Once the generator is finished, the new files will be available at <code>example/demo-component/</code>. To include the web component in the example template add the following line to the template inside the article element:</p>
            <codeblock>{% include \"example/demo-component\" %}</codeblock>"
        },
        "webModules": {
            "heading": "Web Modules",
            "body": "<p>There are two types of web modules. Web modules can act like NPM packages that provide unique functionality to a project, however, this type of web module is extremely project/design specific, so instead  we'll focus on state manager type. A web module's primary role is to manage a state model and handle the communication between web components. Web components should not directly communicate with one another, even when web components are located within the view of another web component. Components should be calling public methods on the web module allowing the module to manage the state model or handle communicating with an API. Then web components should listen for an update event so they can handle the new state when the web module has finished updating the state.</p>
            <p>Creating a state manager type web module is easy in Papertrain when using the code generator. Web modules are generated as a TypeScript file in the <code>web-modules/</code> directory. To generate a new state manager web module run the following command in your terminal:</p>
            <codeblock>npm run create</codeblock>
            <p>Then enter the name of your web module and select <code>Web Module</code> from the list. Web modules use the <code>export</code> keyword to export an instance of the class that will be used by any web component that needs to communicate with it. Web components can import the web module by using the <code>import</code> keyword. For more information about importing and exporting <a href\"https://v8.dev/features/modules\" target=\"_blank\">click here</a> to learn more about ES Modules. Below is an example of how a web module can be imported into a web component.</p>
            <codeblock>import { exampleModule } from '../web-modules/example-module';</codeblock>"
        },
        "npmPackages": {
            "heading": "Adding NPM Packages",
            "body": "<p>Papertrain uses <a href=\"https://rollupjs.org/guide/en/\" target=\"_blank\">rollup.js</a> to bundle NPM packages for use on the web. However, Papertrains implementation of rollup is unique. One of the issues of using rollup is that all imports are resolved by pulling in the source code into the file that contained the import. This means every file that includes an NPM package will include the same source code as all the other files. The heavly contribues to file size bloat and slower load/parsing times. Papertrains provided solution is to rollup the import into a single file. The import is bundled in an IIFE allowing the developer to choose how the bundle will be exported using the <code>export</code> keyword.</p>
            <p>A question you may have is, \"if I only need one small NPM package why don't we just use rollup the way it was intended and allow it to rollup the source into the one web component I need?\". The simple answer is that rollup wouldn't play nicely with ES Modules. Since they use the same import statements rollup would try to pull in all our web modules along with any NPM packages.</p>
            <p>Including a new NPM package into the project is simple. First, you start by installing the NPM package using NPM and your terminal:</p>
            <codeblock>npm i -S uuid</codeblock>
            <p>Now that the package <code>uuid</code> is saved as a dependency in the <code>package.json</code> we can import it. Create a new file called <code>uuid.js</code> in the <code>packages/</code> directory. Open the file and add the following line of JavaScript:</p>
            <codeblock>import uuid from 'uuid/v4';<br/>uuid();</codeblock>
            <p>Then how you proceed with the package is up to you. You could clean up the IIFE to be exported (see the default device manager package) or you could make the package available on the window. When making packages available on the window instead of exporting them you'll need to add a render-blocking script tag to the DOM or you'll need to dynamically load the package when your web component is connected. To make the uuid generator available on the window update the <code>v4_1();</code> line to be:</p>
            <codeblock>window.uuid = v4_1();</codeblock>
            <p>The preferred method for handling NPM packages is to export the package. Especially if it needs to be reused, an example of a reusable package would be <a href=\"https://github.com/juliangarnier/anime/\" target=\"_blank\">animejs</a>.</p>"
        },
        "libraries": {
            "heading": "Adding 3rd Party Libraries",
            "body": "<p>Libraries can be included in two ways. First, they can be included in a <code>&lt;script&gt;</code> element. If you want to ensure the library loads before your web component don't defer or async the script tag. The other option is to include the library's source code in the <code>libraries/</code> directory. Depending on the library you could wrap the library to use the <code>export</code> keyword allowing you to import the library using the <code>import</code> keyword.</p>
            <p>Loading libraries using a render-blocking script tag is not recommended. It's recommended that you figure out how to wrap the library in an export or how to lazy load the library. If you choose to lazy load the script only load when the web component is connected so you don't hurt the  overall page performance.</p>"
        }
    }
%}

{% extends "_layouts/page" %}

{% block content %}
    <article id="homepage" eager-load-css="homepage">
        <section id="intro">
            <div>
                <h1>
                    {{ dataModel.intro }}
                </h1>
                <p>{{ dataModel.introCopy|raw }}</p>
                <nav>
                    {% for link in dataModel.links %}
                        <a href="{{ link.name }}">
                            {{ link.label }}
                            <svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="long-arrow-right" class="svg-inline--fa fa-long-arrow-right fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M295.515 115.716l-19.626 19.626c-4.753 4.753-4.675 12.484.173 17.14L356.78 230H12c-6.627 0-12 5.373-12 12v28c0 6.627 5.373 12 12 12h344.78l-80.717 77.518c-4.849 4.656-4.927 12.387-.173 17.14l19.626 19.626c4.686 4.686 12.284 4.686 16.971 0l131.799-131.799c4.686-4.686 4.686-12.284 0-16.971L312.485 115.716c-4.686-4.686-12.284-4.686-16.97 0z"></path></svg>
                        </a>
                    {% endfor %}
                </nav>
            </div>
        </section>
        <section>
            <a name="templates">
                <h2>{{ dataModel.templates.heading }}</h2>
            </a>
            {{ dataModel.templates.body|raw }}
        </section>
        <section>
            <a name="web-components">
                <h2>{{ dataModel.webComponents.heading }}</h2>
            </a>
            {{ dataModel.webComponents.body|raw }}
        </section>
        <section>
            <a name="web-modules">
                <h2>{{ dataModel.webModules.heading }}</h2>
            </a>
            {{ dataModel.webModules.body|raw }}
        </section>
        <section>
            <a name="npm-packages">
                <h2>{{ dataModel.npmPackages.heading }}</h2>
            </a>
            {{ dataModel.npmPackages.body|raw }}
        </section>
        <section>
            <a name="libraries">
                <h2>{{ dataModel.libraries.heading }}</h2>
            </a>
            {{ dataModel.libraries.body|raw }}
        </section>
    </article>
{% endblock %}
